Cheat Sheet:

taints:
kubectl taint nodes node01 spray=mortein:NoSchedule
Run the command: kubectl taint nodes controlplane node-role.kubernetes.io/control-plane:NoSchedule- to untaint the node.

Which node is the POD mosquito on now?
Run the command kubectl get pods -o wide and look at the Node column.

create yaml file:
kubectl run simonpod --image=nginx --dry-run=client -o yaml > simonpod.yaml

labels:
kubectl label nodes <node name> labelkey=label vlaue

Node Affinity:
to see labels in json with jq parser:
kubectl get node node01 -o json | jq '.metadata.labels'

Create a new deployment named blue with the nginx image and 3 replicas:
kubectl create deployment blue --image=nginx --replicas=3
kubecrl create deployment red --image=nginx --replicas=2 --dry-run=client -o yaml > red.yaml 

to edit existing deployment:
kubectl edit deployment <name>

daemonsets - to monitor the cluster (kube-proxy)
How many DaemonSets are created in the cluster in all namespaces?
kubectl get daemonsets --all-namespaces

On how many nodes are the pods scheduled by the DaemonSet kube-proxy?
kubectl describe daemonset kube-proxy --namespace=kube-system

An easy way to create a DaemonSet is to start by generating a Deployment YAML using:
kubectl create deployment elasticsearch --image=registry.k8s.io/fluentd-elasticsearch:1.20 -n kube-system --dry-run=client -o yaml > fluentd.yaml
Then, edit the YAML as follows:
Change: kind: Deployment â†’ kind: DaemonSet
Ensure: apiVersion: apps/v1
Remove these fields from the YAML:
spec.replicas
spec.strategy
status (entire section, if present)
Finally, create the DaemonSet using:
kubectl create -f fluentd.yaml

to see all daemonsets on all namespaces:
kubectl get daemonsets.apps --all-namespaces

to see all deployments on all namespaces:
kubectl get deployments --all-namespaces

static Pods:
What is the path of the directory holding the static pod definition files?
Run the command ps -aux | grep kubelet and identify the config file - --config=/var/lib/kubelet/config.yaml. Then check in the config file for staticPodPath.

Create a static pod named static-busybox that uses the busybox image , run in the default namespace and the command sleep 1000
kubectl run --restart=Never --image=busybox static-busybox --dry-run=client -o yaml --command -- sleep 1000 > /etc/kubernetes/manifests/static-busybox.yaml

Check the Pod's schedulerName
You can view the schedulerName field using the kubectl get pod command with a specific output format: 
bash
kubectl get pod <pod-name> -o jsonpath='{.spec.schedulerName}'

to see admission-plugins - disabled/enabled:
ps -ef | grep kube-apiserver | grep admission-plugins - only if its running as pod.

rollbacks and updating:
kubectl create -f deployment-definition.yml
kubectl get deployments
kubectl apply -f deployment-definiton.yml
kubectl set image deployment/myapp-deploymnet nginx=nginx:1.9.1
kubectl rollout status deployment/myapp-deployment
kubectl rollout history deployment/myapp-deployment

creating configmap
kubectl create configmap  webapp-config-map --from-literal=APP_COLOR=darkblue --from-literal=APP_OTHER=disregard

#Update the environment variable on the POD to use only the APP_COLOR key from the newly created ConfigMap.#
---
apiVersion: v1
kind: Pod
metadata:
  labels:
    name: webapp-color
  name: webapp-color
  namespace: default
spec:
  containers:
  - env:
    - name: APP_COLOR
      valueFrom:
       configMapKeyRef:
         name: webapp-config-map
         key: APP_COLOR
    image: kodekloud/webapp-color
    name: webapp-color
