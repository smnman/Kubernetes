Cheat Sheet:

taints:
kubectl taint nodes node01 spray=mortein:NoSchedule
Run the command: kubectl taint nodes controlplane node-role.kubernetes.io/control-plane:NoSchedule- to untaint the node.

Which node is the POD mosquito on now?
Run the command kubectl get pods -o wide and look at the Node column.

create yaml file:
kubectl run simonpod --image=nginx --dry-run=client -o yaml > simonpod.yaml

labels:
kubectl label nodes <node name> labelkey=label vlaue

Node Affinity:
to see labels in json with jq parser:
kubectl get node node01 -o json | jq '.metadata.labels'

Create a new deployment named blue with the nginx image and 3 replicas:
kubectl create deployment blue --image=nginx --replicas=3
kubecrl create deployment red --image=nginx --replicas=2 --dry-run=client -o yaml > red.yaml 

to edit existing deployment:
kubectl edit deployment <name>

daemonsets - to monitor the cluster (kube-proxy)
How many DaemonSets are created in the cluster in all namespaces?
kubectl get daemonsets --all-namespaces

On how many nodes are the pods scheduled by the DaemonSet kube-proxy?
kubectl describe daemonset kube-proxy --namespace=kube-system

An easy way to create a DaemonSet is to start by generating a Deployment YAML using:
kubectl create deployment elasticsearch --image=registry.k8s.io/fluentd-elasticsearch:1.20 -n kube-system --dry-run=client -o yaml > fluentd.yaml
Then, edit the YAML as follows:
Change: kind: Deployment â†’ kind: DaemonSet
Ensure: apiVersion: apps/v1
Remove these fields from the YAML:
spec.replicas
spec.strategy
status (entire section, if present)
Finally, create the DaemonSet using:
kubectl create -f fluentd.yaml

to see all daemonsets on all namespaces:
kubectl get daemonsets.apps --all-namespaces

to see all deployments on all namespaces:
kubectl get deployments --all-namespaces

static Pods:
What is the path of the directory holding the static pod definition files?
Run the command ps -aux | grep kubelet and identify the config file - --config=/var/lib/kubelet/config.yaml. Then check in the config file for staticPodPath.

Create a static pod named static-busybox that uses the busybox image , run in the default namespace and the command sleep 1000
kubectl run --restart=Never --image=busybox static-busybox --dry-run=client -o yaml --command -- sleep 1000 > /etc/kubernetes/manifests/static-busybox.yaml

Check the Pod's schedulerName
You can view the schedulerName field using the kubectl get pod command with a specific output format: 
bash
kubectl get pod <pod-name> -o jsonpath='{.spec.schedulerName}'

to see admission-plugins - disabled/enabled:
ps -ef | grep kube-apiserver | grep admission-plugins - only if its running as pod.

rollbacks and updating:
kubectl create -f deployment-definition.yml
kubectl get deployments
kubectl apply -f deployment-definiton.yml
kubectl set image deployment/myapp-deploymnet nginx=nginx:1.9.1
kubectl rollout status deployment/myapp-deployment
kubectl rollout history deployment/myapp-deployment

creating configmap
kubectl create configmap  webapp-config-map --from-literal=APP_COLOR=darkblue --from-literal=APP_OTHER=disregard

##############################################
#Update the environment variable on the POD to use only the APP_COLOR key from the newly created ConfigMap.#
---
apiVersion: v1
kind: Pod
metadata:
  labels:
    name: webapp-color
  name: webapp-color
  namespace: default
spec:
  containers:
  - env:
    - name: APP_COLOR
      valueFrom:
       configMapKeyRef:
         name: webapp-config-map
         key: APP_COLOR
    image: kodekloud/webapp-color
    name: webapp-color
##############################################

secrets:
creating secret Imperative way:
kubectl create secret generic <secret-name> --from-literal=key=value
kubectl create secret generic app-secret --from-literal=DB_HOST=mysql --from-literal=DB_USER=root --from-literal=DB_PASSWORD=abc123!
kubectl create secret generic app-secret --from-file=app_secret.properites

##############################################
declartive:
kubectl create -f
apiVersion: v1
kind: Secret
metdara:
  name: app-secret
data:
  DB_HOST: mysql
  DB_User: root
  DB_PASS: 123123!
##############################################

encoding secrets:
echo -n 'mysql' | base64
echo -n 'root' | base64
echp -n 'passwrd' | base64 
decode:
echo -n 'mysql' | base64 --decode
echo -n 'root' | base64 --decode
echp -n 'passwrd' | base64 --decode

kubectl get secrets - to view secret
kubectl describe secrets

Step 1: Get the Existing Pod Definition
kubectl get pod webapp-pod -o yaml > webapp-pod.yaml
Step 2:
Configure the webapp-pod to load environment variables from the db-secret secret you created in the previous task.
##############################################
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: "2026-01-30T21:14:28Z"
  generation: 1
  labels:
    name: webapp-pod
  name: webapp-pod
  namespace: default
  resourceVersion: "1062"
  uid: 5eb8d887-7774-4dc0-9cbd-b1d563f99cae
spec:
  containers:
  - image: kodekloud/simple-webapp-mysql
    imagePullPolicy: Always
    envFrom:
    - secretRef:
        name: db-secret
##############################################
